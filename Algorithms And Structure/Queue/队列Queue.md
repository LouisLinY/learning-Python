## 队列Queue

### 1.1  认识队列

- **队列是一种有次序的数据集合，其特征是**

  新数据项的添加总发生在一端（通常称为“尾rear" 端）

  而现存数据项的移除总发生在另一端

- **当数据项加入队列，首先出现在队尾，随着队首数据项的移除，它逐渐接近队首**

- **新加入的数据项必须在数据集末尾等待，而等待时间最长的数据项则是队首**

- **这种次序安排的原则称为（FIFO， First-in First Out）**，即先到先服务

- **队列的例子出现在我们日常生活的方方面面：排队、打印队列**

- **队列仅有一个入口和一个出口**（不允许数据项直接插入队中，也不允许从中间移除数据项



### 1.2  计算机科学中队列的样子：进程调度

- **操作系统核心采用对个队列来对系统中同时运行的进程进行调度**

  进程数多于cpu核心数

  有些进程还要等待不同类型的I/O事件（慢与cpu）

- **调度原则综合了“先到先服务”及：“资源充分利用“两个出发点**



### 1.3  抽象数据类型Queue

- **抽象数据类型Queue是一个有次序的数据集合**

  数据项仅添加到“尾rear”端

  而且仅从“首front”端移除

  Queue具有FIFO的操作次序

- **抽象数据类型Queue具有如下操作定义：**

  Queue()：创建一个空队列对象，返回值为Queue对象；

  enqueue(item)：将数据项item添加到队尾，无返回值；

  dequeue()：从队首移除数据项，返回为队首数据项，队列被修改；

  isEmpty()：测试是否空队列，返回值为布尔值

  size()：返回队列中数据项的个数

- **操作实例**

  |     队列操作     |       队列内容        |    返回值    |
  | :--------------: | :-------------------: | :----------: |
  |    q=Queue()     |          []           | Queue Object |
  |   q.isEmpty()    |          []           |     True     |
  |   q.enqueue(4)   |          [4]          |              |
  | q.enqueue('dog') |      ['dog', 4]       |              |
  | q.enqueue(True)  |   [True, 'dog', 4]    |              |
  |     q.size()     |   [True, 'dog', 4]    |      3       |
  |   q.isEmpty()    |   [True, 'dog', 4]    |    False     |
  |  q.enqueue(8.4)  | [8.4, True, 'dog', 4] |              |
  |   q.dequeue()    |  [8.4, True, 'dog']   |      4       |
  |   q.dequeue()    |      [8.4, True]      |    'dog'     |
  |     q.size()     |      [8.4, True]      |      2       |



### 1.4  Python实现ADT Queue

- **采用List来容纳Queue的数据项**

  将List首端作为队列尾，List的末端作为队列首端，`enqueue()` 复杂度为 **O(n)**；`dequeue()`复杂度为 **O(1)**

- **首尾倒过来的实现，复杂度也倒过来**

```python
class Queue():
	def __init__(self):
		self._items = []
	
	def isEmpty(self):
		return self._items == []
	
	def enqueue(self, item):
		self._items.insert(0, item)
		
	def dequeue(self):
		return self._items.pop()
	
	def size(self):
		return len(self._items)
```





### 2.1  队列的应用：热土豆问题（约瑟夫问题）

- **约瑟夫问题**

  传说犹太人反叛罗马人，落到困境，约瑟夫和39人决定殉难，坐在一圈儿，报数1~7，报到7的人由旁边杀死，结果约瑟夫给自己安排了个位置，最后活下来....

- 用队列来实现热土豆问题的算法，参加游戏的人名列表，以及传土豆数num，算法返回最后剩下的人名

- 模拟程序采用队列来存放所有参加游戏的人名，按照传递土豆方向从队首排到队尾

  游戏时，队首始终是持有土豆的人

- 模拟游戏开始，只需要将队首的人出队，随即在到队尾入队，算是土豆的一次传递

  传递了num次后，将队首的人移除，不再入队如此反复，知道队列中剩余1人



### 2.2  模拟算法：打印任务

多人共享一台打印机，采取“先到先服务”的队列策略来执行打印任务，这种设定下，一个首要的问题就是：这种打印作业系统的容量有多大？在能够接受的等待时间内，系统能容纳多少用户以多高频率提交多少打印任务？

- 一个具体的实例配置如下：

一个实验室，在任意的一个小时内，大约有10名学生在场，这一个小时中，每人会发起2次左右的打印，每次1~20页

- 打印机的性能

  以草稿模式打印的话，每分钟10页

  以正常模式打印的话，打印质量中，但速度下降为每分钟5页。

- 问题：怎么设置打印机的模式，让大家都不会等太久的前提下尽量提高打印质量？

- 这是一个典型的决策支持问题，但无法通过规则直接计算

- 我们要用一段程序来模拟这种打印任务场景，然后对程序运行结果进行分析，以支持对打印机模式的设定的决策

- 首相对问题进行抽象，确定相关的对象和过程

- 如何对问题建模

  对象：打印任务、打印队列、打印机

  打印任务的属性：提交时间，打印页数

  打印队列的属性：具有FIFO性质的打印任务队列

  打印机的属性：打印速度，是否忙

  过程：生成和提交打印任务

  确定生成概率：实例为每小时会有10个学生提交的20个作业，这样，概率是每180秒会有1个作业生成并提交，概率为每秒1/180。

  确定打印页数：实例是1~20页，那么就是1-20页之间概率相同。

  20tasks/1hour * 1hour/60minutes * 1minutes/60seconds = 1tasks/180seconds

- 过程：实施打印

  当前的打印作业：正在打印的作业

  打印结束倒计时：新作业开始打印时开始倒计时，回0表示打印完毕，可以处理下一个任务

- 默认时间：统一的时间框架：以最小单位（秒）均匀流逝的时间，设定结束时间，同步所有过程：在一个小时单位里，对生成打印任务和实施打印两个过程各处理一次（在时间流逝的过程中，就要同步所有的过程，也就是在一个时间单位里，就要对生成打印作业任务和实施，打印这两件过程各自处理一次，在一秒钟内就要分别处理一次，处理完成了以后再进行下一秒，直到模拟的时间完全用完，结束这个模拟）

- 创建打印队列对象

- 时间按照秒的单位流逝

  按照概率生成打印作业，加入打印队列，如果打印机空闲，且队列不空，则取出队首作业打印，记录此作业等待时间；如果打印机忙，则按照打印速度进行1秒打印；如果打印当前作业打印完成，则打印机进入空闲

- 时间用尽，开始统计平均等待时间

- 作业的等待时间

  生成作业时，记录生成的时间戳

  开始打印时，当前时间减去生成时间即可

- 作业的打印时间

  生成作业时，记录作业的页数

  开始打印时，页数除以打印速度即可

- 111

- 11

- 111

- 111

- 111

- 111

- 111

- 111



