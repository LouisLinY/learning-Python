## 队列Queue

### 1.1  认识队列

- **队列是一种有次序的数据集合，其特征是**

  新数据项的添加总发生在一端（通常称为“尾rear" 端）

  而现存数据项的移除总发生在另一端

- **当数据项加入队列，首先出现在队尾，随着队首数据项的移除，它逐渐接近队首**

- **新加入的数据项必须在数据集末尾等待，而等待时间最长的数据项则是队首**

- **这种次序安排的原则称为（FIFO， First-in First Out）**，即先到先服务

- **队列的例子出现在我们日常生活的方方面面：排队、打印队列**

- **队列仅有一个入口和一个出口**（不允许数据项直接插入队中，也不允许从中间移除数据项



### 1.2  计算机科学中队列的样子：进程调度

- **操作系统核心采用对个队列来对系统中同时运行的进程进行调度**

  进程数多于cpu核心数

  有些进程还要等待不同类型的I/O事件（慢与cpu）

- **调度原则综合了“先到先服务”及：“资源充分利用“两个出发点**



### 1.3  抽象数据类型Queue

- **抽象数据类型Queue是一个有次序的数据集合**

  数据项仅添加到“尾rear”端

  而且仅从“首front”端移除

  Queue具有FIFO的操作次序

- **抽象数据类型Queue具有如下操作定义：**

  Queue()：创建一个空队列对象，返回值为Queue对象；

  enqueue(item)：将数据项item添加到队尾，无返回值；

  dequeue()：从队首移除数据项，返回为队首数据项，队列被修改；

  isEmpty()：测试是否空队列，返回值为布尔值

  size()：返回队列中数据项的个数

- **操作实例**

  |     队列操作     |       队列内容        |    返回值    |
  | :--------------: | :-------------------: | :----------: |
  |    q=Queue()     |          []           | Queue Object |
  |   q.isEmpty()    |          []           |     True     |
  |   q.enqueue(4)   |          [4]          |              |
  | q.enqueue('dog') |      ['dog', 4]       |              |
  | q.enqueue(True)  |   [True, 'dog', 4]    |              |
  |     q.size()     |   [True, 'dog', 4]    |      3       |
  |   q.isEmpty()    |   [True, 'dog', 4]    |    False     |
  |  q.enqueue(8.4)  | [8.4, True, 'dog', 4] |              |
  |   q.dequeue()    |  [8.4, True, 'dog']   |      4       |
  |   q.dequeue()    |      [8.4, True]      |    'dog'     |
  |     q.size()     |      [8.4, True]      |      2       |



### 1.4  Python实现ADT Queue

- **采用List来容纳Queue的数据项**

  将List首端作为队列尾，List的末端作为队列首端，`enqueue()` 复杂度为 **O(n)**；`dequeue()`复杂度为 **O(1)**

- **首尾倒过来的实现，复杂度也倒过来**

```python
class Queue():
	def __init__(self):
		self._items = []
	
	def isEmpty(self):
		return self._items == []
	
	def enqueue(self, item):
		self._items.insert(0, item)
		
	def dequeue(self):
		return self._items.pop()
	
	def size(self):
		return len(self._items)
```





### 2.1  队列的应用：热土豆问题（约瑟夫问题）

- **约瑟夫问题**

  传说犹太人反叛罗马人，落到困境，约瑟夫和39人决定殉难，坐在一圈儿，报数1~7，报到7的人由旁边杀死，结果约瑟夫给自己安排了个位置，最后活下来....

- 用队列来实现热土豆问题的算法，参加游戏的人名列表，以及传土豆数num，算法返回最后剩下的人名

- 模拟程序采用队列来存放所有参加游戏的人名，按照传递土豆方向从队首排到队尾

  游戏时，队首始终是持有土豆的人

- 模拟游戏开始，只需要将队首的人出队，随即在到队尾入队，算是土豆的一次传递

  传递了num次后，将队首的人移除，不再入队如此反复，知道队列中剩余1人

- 1111

- 2222

- 4444

- 66

- 88

- 99

- 99

- 655



